// Copyright 2024 The GitVault Authors. All rights reserved.
// SPDX-License-Identifier: MIT

package phantomkit

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"io"
	"time"
	"bytes"

	"code.gitea.io/gitea/modules/log"
	"code.gitea.io/gitea/modules/storage"
)

// PhantomKit represents the main service for managing code storage and retrieval
type PhantomKit struct {
	storage storage.ObjectStorage
	cache   *Cache
}

// Cache represents an ephemeral cache for code blobs
type Cache struct {
	entries map[string]*CacheEntry
	ttl     time.Duration
}

// CacheEntry represents a cached code blob
type CacheEntry struct {
	Data      []byte
	Hash      string
	ExpiresAt time.Time
}

// New creates a new PhantomKit instance
func New(storage storage.ObjectStorage, cacheTTL time.Duration) *PhantomKit {
	return &PhantomKit{
		storage: storage,
		cache: &Cache{
			entries: make(map[string]*CacheEntry),
			ttl:     cacheTTL,
		},
	}
}

// StoreCode stores a code blob and returns its hash
func (pk *PhantomKit) StoreCode(ctx context.Context, projectID, scriptName string, code []byte) (string, error) {
	hash := generateHash(code)
	key := fmt.Sprintf("%s/%s/%s", projectID, scriptName, hash)
	
	// Store in persistent storage
	_, err := pk.storage.Save(key, bytes.NewReader(code), int64(len(code)))
	if err != nil {
		return "", fmt.Errorf("failed to store code: %w", err)
	}
	
	// Cache the code
	pk.cache.Set(key, code, hash)
	
	log.Info("Code stored successfully: %s", key)
	return hash, nil
}

// LoadCode retrieves a code blob by project ID and script name
func (pk *PhantomKit) LoadCode(ctx context.Context, projectID, scriptName, hash string) ([]byte, error) {
	key := fmt.Sprintf("%s/%s/%s", projectID, scriptName, hash)
	
	// Check cache first
	if cached := pk.cache.Get(key); cached != nil {
		log.Debug("Code loaded from cache: %s", key)
		return cached.Data, nil
	}
	
	// Load from storage
	reader, err := pk.storage.Open(key)
	if err != nil {
		return nil, fmt.Errorf("failed to load code: %w", err)
	}
	defer reader.Close()
	
	code, err := io.ReadAll(reader)
	if err != nil {
		return nil, fmt.Errorf("failed to read code: %w", err)
	}
	
	// Cache the loaded code
	pk.cache.Set(key, code, hash)
	
	log.Debug("Code loaded from storage: %s", key)
	return code, nil
}

// GenerateLoader generates a language-specific loader file
func (pk *PhantomKit) GenerateLoader(projectID, scriptName, language string) (string, error) {
	switch language {
	case "javascript", "js":
		return pk.generateJSLoader(projectID, scriptName), nil
	case "typescript", "ts":
		return pk.generateTSLoader(projectID, scriptName), nil
	case "python", "py":
		return pk.generatePythonLoader(projectID, scriptName), nil
	default:
		return "", fmt.Errorf("unsupported language: %s", language)
	}
}

// generateJSLoader generates a JavaScript loader file
func (pk *PhantomKit) generateJSLoader(projectID, scriptName string) string {
	return fmt.Sprintf(`// Generated by GitVault PhantomKit
// Project: %s
// Script: %s

import { PhantomKit } from 'phantomkit';

const phantom = new PhantomKit(process.env.PKIT_KEY);

// Load and execute the script
async function loadScript() {
  try {
    await phantom.load('%s');
    console.log('Script loaded successfully');
  } catch (error) {
    console.error('Failed to load script:', error);
  }
}

loadScript();
`, projectID, scriptName, scriptName)
}

// generateTSLoader generates a TypeScript loader file
func (pk *PhantomKit) generateTSLoader(projectID, scriptName string) string {
	return fmt.Sprintf(`// Generated by GitVault PhantomKit
// Project: %s
// Script: %s

import { PhantomKit } from 'phantomkit';

const phantom = new PhantomKit(process.env.PKIT_KEY);

// Load and execute the script
async function loadScript(): Promise<void> {
  try {
    await phantom.load('%s');
    console.log('Script loaded successfully');
  } catch (error) {
    console.error('Failed to load script:', error);
  }
}

loadScript();
`, projectID, scriptName, scriptName)
}

// generatePythonLoader generates a Python loader file
func (pk *PhantomKit) generatePythonLoader(projectID, scriptName string) string {
	return fmt.Sprintf(`# Generated by GitVault PhantomKit
# Project: %s
# Script: %s

import os
from phantomkit import PhantomKit

phantom = PhantomKit(os.getenv('PKIT_KEY'))

# Load and execute the script
async def load_script():
    try:
        await phantom.load('%s')
        print('Script loaded successfully')
    except Exception as error:
        print(f'Failed to load script: {{error}}')

load_script()
`, projectID, scriptName, scriptName)
}

// generateHash generates a SHA256 hash of the code
func generateHash(code []byte) string {
	hash := sha256.Sum256(code)
	return hex.EncodeToString(hash[:])
}

// Set stores a value in the cache
func (c *Cache) Set(key string, data []byte, hash string) {
	c.entries[key] = &CacheEntry{
		Data:      data,
		Hash:      hash,
		ExpiresAt: time.Now().Add(c.ttl),
	}
}

// Get retrieves a value from the cache if it exists and hasn't expired
func (c *Cache) Get(key string) *CacheEntry {
	entry, exists := c.entries[key]
	if !exists {
		return nil
	}
	
	if time.Now().After(entry.ExpiresAt) {
		delete(c.entries, key)
		return nil
	}
	
	return entry
}

// Cleanup removes expired entries from the cache
func (c *Cache) Cleanup() {
	now := time.Now()
	for key, entry := range c.entries {
		if now.After(entry.ExpiresAt) {
			delete(c.entries, key)
		}
	}
}
